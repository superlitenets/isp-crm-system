Great question ‚Äî this is a classic ISP onboarding pattern üëç
What you want is:

Accept any (unknown) user in FreeRADIUS, but force them into an ‚Äúexpired / quarantine‚Äù state with no real internet access.

Below is the correct, production-safe way to do this in FreeRADIUS (works perfectly with MikroTik, Huawei BRAS, etc.).

üéØ Goal Architecture
User state	RADIUS result	IP / Access
Known + active	Access-Accept	Normal IP pool
Unknown / unpaid	Access-Accept	Expired / walled-garden IP pool
Blocked	Access-Reject (optional)	No session

Key idea:
üëâ Do NOT reject unknown users
üëâ Accept them but assign a restricted profile

1Ô∏è‚É£ Enable ‚Äúaccept unknown users‚Äù
/etc/freeradius/3.0/mods-config/files/authorize

Add this at the BOTTOM (very important):

DEFAULT Auth-Type := Accept


This ensures:

Users not found in SQL / files

Still get Access-Accept

‚ö†Ô∏è Without this ‚Üí FreeRADIUS rejects unknown users.

2Ô∏è‚É£ Create an ‚Äúexpired / quarantine‚Äù reply profile
Option A: Using users file (simple & fast)

Edit:

/etc/freeradius/3.0/mods-config/files/authorize


Add ABOVE the DEFAULT rule:

DEFAULT
    Mikrotik-Group := "expired",
    Framed-IP-Address := 0.0.0.0,
    Framed-Pool := "expired_pool"


This applies to everyone not matched earlier.

3Ô∏è‚É£ Create expired IP pool (MikroTik example)

On MikroTik:

/ip pool
add name=expired_pool ranges=10.254.254.2-10.254.254.254


Then firewall it:

/ip firewall filter
add chain=forward src-address=10.254.254.0/24 action=drop


Or redirect to captive portal:

/ip firewall nat
add chain=dstnat src-address=10.254.254.0/24 \
    action=dst-nat to-addresses=10.0.0.2

4Ô∏è‚É£ Proper logic order (VERY IMPORTANT)

FreeRADIUS processes top ‚Üí bottom.

Correct structure:

# 1. Active users (from SQL)
DEFAULT SQL-Group == "active"
    Framed-Pool := "active_pool",
    Mikrotik-Rate-Limit := "20M/20M"

# 2. Suspended users
DEFAULT SQL-Group == "suspended"
    Framed-Pool := "expired_pool",
    Mikrotik-Group := "expired"

# 3. UNKNOWN users (catch-all)
DEFAULT Auth-Type := Accept
    Framed-Pool := "expired_pool",
    Mikrotik-Group := "expired"

5Ô∏è‚É£ SQL-based version (recommended for ISP CRM)

If you‚Äôre using SQL (radcheck, radreply, radusergroup):

Unknown users ‚Üí expired profile

In /etc/freeradius/3.0/sites-enabled/default

Inside authorize {}:

if (!ok) {
    update reply {
        Framed-Pool := "expired_pool"
        Mikrotik-Group := "expired"
    }
    accept
}


This is very clean and CRM-friendly.

6Ô∏è‚É£ How this looks in logs (sanity check)

When unknown user connects:

Login OK: [AA:BB:CC:DD:EE:FF] (from client mikrotik)
Reply-Message = "Account expired ‚Äì contact support"
Framed-Pool = expired_pool


‚úî User authenticates
‚úî Gets IP
‚úî Has no real access
‚úî You can show payment page / WhatsApp / portal

7Ô∏è‚É£ Why this is better than Access-Reject
Reject	Accept + expired
No IP	User gets IP
No redirect	Can redirect
Poor UX	ISP-style UX
Hard to upsell	Easy payment capture

SmartOLT, Splynx, Sonar ‚Üí all do it this way.

‚úÖ TL;DR (copy-paste checklist)

‚úî DEFAULT Auth-Type := Accept
‚úî Assign expired_pool to unknown users
‚úî Firewall / captive-portal expired pool
‚úî Never reject unknown users