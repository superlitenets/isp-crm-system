Below is a clean, production-grade separation of processes, with real PHP code, designed for:

Huawei HG8546M

GenieACS

Multi-session TR-069

Zero ‚ÄúInvalid parameter path‚Äù

No reboot dependency

I‚Äôll give you 4 separate PHP processes, each with clear responsibility and strict boundaries.

üß† Overall Architecture (IMPORTANT)

Each process is independent, idempotent, and state-driven.

ONU ‚Üí GenieACS
        ‚Üì
 Authorization & Ownership
        ‚Üì
 TR-069 Management WAN & Profile
        ‚Üì
 Service WAN (PPPoE / Bridge)
        ‚Üì
 Wi-Fi Configuration


‚ö†Ô∏è No process skips ahead
‚ö†Ô∏è Each waits for a new Inform

1Ô∏è‚É£ Authorization & ACS Ownership Process

üìÑ Tr069Authorization.php

Responsibility

Take ACS ownership

Set connection-request credentials

NOTHING else

<?php

class Tr069Authorization
{
    private GenieACS $acs;

    public function __construct(GenieACS $acs)
    {
        $this->acs = $acs;
    }

    public function handle(string $deviceId): void
    {
        $this->acs->push($deviceId, [
            [
                "name" => "setParameterValues",
                "parameterValues" => [
                    ["InternetGatewayDevice.ManagementServer.URL", ACS_URL, "xsd:string"],
                    ["InternetGatewayDevice.ManagementServer.ConnectionRequestUsername", "genieacs", "xsd:string"],
                    ["InternetGatewayDevice.ManagementServer.ConnectionRequestPassword", "StrongPass123", "xsd:string"]
                ]
            ]
        ]);

        // State ‚Üí OWNED
    }
}


‚úî Safe
‚úî One-time
‚úî No dependency on WAN / Wi-Fi

2Ô∏è‚É£ TR-069 Management WAN & Profile Process

üìÑ Tr069Profile.php

Responsibility

Ensure time is valid

Ensure management WAN exists

No service WANs

No Wi-Fi

<?php

class Tr069Profile
{
    private GenieACS $acs;

    public function __construct(GenieACS $acs)
    {
        $this->acs = $acs;
    }

    public function handle(string $deviceId, array $device): void
    {
        $time = $device['InternetGatewayDevice.DeviceInfo.CurrentTime'] ?? null;

        if (!$time || intval(substr($time, 0, 4)) < 2020) {
            $this->acs->push($deviceId, [[
                "name" => "setParameterValues",
                "parameterValues" => [
                    ["InternetGatewayDevice.Time.NTPServer1", "pool.ntp.org", "xsd:string"],
                    ["InternetGatewayDevice.Time.Enable", true, "xsd:boolean"]
                ]
            ]]);
            return; // WAIT FOR NEXT INFORM
        }

        // State ‚Üí READY
    }
}


‚úî Prevents 1981-01-01
‚úî Prevents early provisioning
‚úî Matches SmartOLT behavior

3Ô∏è‚É£ Service WAN Configuration Process (PPPoE / Bridge)

üìÑ ServiceWanProvisioner.php

Responsibility

Create WANDevice

Create WANConnectionDevice

Create WANPPPConnection

Configure PPPoE

NO Wi-Fi

NO policy routing yet

<?php

class ServiceWanProvisioner
{
    private GenieACS $acs;

    public function __construct(GenieACS $acs)
    {
        $this->acs = $acs;
    }

    public function createWanDevice(string $deviceId): void
    {
        $this->acs->push($deviceId, [[
            "name" => "addObject",
            "objectName" => "InternetGatewayDevice.WANDevice."
        ]]);
    }

    public function createWanConnectionDevice(string $deviceId, string $wanDevicePath): void
    {
        $this->acs->push($deviceId, [[
            "name" => "addObject",
            "objectName" => "$wanDevicePath.WANConnectionDevice."
        ]]);
    }

    public function createPppConnection(string $deviceId, string $connPath): void
    {
        $this->acs->push($deviceId, [[
            "name" => "addObject",
            "objectName" => "$connPath.WANPPPConnection."
        ]]);
    }

    public function configurePppoe(string $deviceId, string $pppPath, array $creds): void
    {
        $this->acs->push($deviceId, [[
            "name" => "setParameterValues",
            "parameterValues" => [
                ["$pppPath.Username", $creds['user'], "xsd:string"],
                ["$pppPath.Password", $creds['pass'], "xsd:string"],
                ["$pppPath.X_HW_VLAN", $creds['vlan'], "xsd:unsignedInt"],
                ["$pppPath.NATEnabled", true, "xsd:boolean"],
                ["$pppPath.Enable", true, "xsd:boolean"]
            ]
        ]]);
    }
}


‚úî Multi-session safe
‚úî No invalid paths
‚úî Huawei-compliant

4Ô∏è‚É£ Wi-Fi Configuration Process

üìÑ WifiConfigurator.php

Responsibility

SSID

Security

Enable radio

No WAN changes

<?php

class WifiConfigurator
{
    private GenieACS $acs;

    public function __construct(GenieACS $acs)
    {
        $this->acs = $acs;
    }

    public function configure(string $deviceId, string $ssid, string $password): void
    {
        $this->acs->push($deviceId, [[
            "name" => "setParameterValues",
            "parameterValues" => [
                ["InternetGatewayDevice.LANDevice.1.WLANConfiguration.1.SSID", $ssid, "xsd:string"],
                ["InternetGatewayDevice.LANDevice.1.WLANConfiguration.1.PreSharedKey.1.KeyPassphrase", $password, "xsd:string"],
                ["InternetGatewayDevice.LANDevice.1.WLANConfiguration.1.Enable", true, "xsd:boolean"]
            ]
        ]]);
    }
}


‚úî Can be retried safely
‚úî Independent of WAN
‚úî No risk to PPPoE

üß© How they are orchestrated (VERY IMPORTANT)

Your main controller only decides what process to call, based on state.

üìÑ ProvisionController.php

switch ($onu['state']) {

    case 'DISCOVERED':
        $auth->handle($deviceId);
        break;

    case 'OWNED':
        $profile->handle($deviceId, $device);
        break;

    case 'READY':
        $wan->createWanDevice($deviceId);
        break;

    case 'WAN_DEVICE_CREATED':
        $wan->createWanConnectionDevice($deviceId, $onu['wan_device_path']);
        break;

    case 'WAN_CONN_CREATED':
        $wan->createPppConnection($deviceId, $onu['wan_conn_path']);
        break;

    case 'WAN_PPP_CREATED':
        $wan->configurePppoe($deviceId, $onu['ppp_path'], $creds);
        break;

    case 'ACTIVE':
        $wifi->configure($deviceId, $ssid, $password);
        break;
}

üßØ Why this design works (summary)
Problem	Solved by
Invalid parameter path	One responsibility per session
9002 internal error	Small CWMP payloads
Needs reboot	Inform between states
PPPoE not created	Explicit ADD chain
Wi-Fi breaks WAN	Hard separation
Hard to debug	Clear process boundaries